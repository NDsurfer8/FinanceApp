import { ref, set, get, push, update, remove } from "firebase/database";
import { db } from "./firebase";
import { Transaction, RecurringTransaction } from "./userData";

// ===== REGULAR TRANSACTIONS CRUD =====

export const createTransaction = async (
  transaction: Omit<Transaction, "id">
): Promise<string> => {
  try {
    // Use the encrypted saveTransaction function from userData.ts
    const { saveTransaction } = await import("./userData");

    const transactionWithId = {
      ...transaction,
      id: "", // Will be generated by saveTransaction
    };

    const transactionId = await saveTransaction(transactionWithId);
    return transactionId;
  } catch (error) {
    console.error("Error creating transaction:", error);
    throw error;
  }
};

export const getTransactions = async (
  userId: string
): Promise<Transaction[]> => {
  try {
    // Use the decrypted getUserTransactions function from userData.ts
    const { getUserTransactions } = await import("./userData");
    return await getUserTransactions(userId);
  } catch (error) {
    console.error("Error getting transactions:", error);
    throw error;
  }
};

export const getTransactionsForMonth = async (
  userId: string,
  month: Date
): Promise<Transaction[]> => {
  try {
    const allTransactions = await getTransactions(userId);
    const monthStart = new Date(month.getFullYear(), month.getMonth(), 1);
    const monthEnd = new Date(month.getFullYear(), month.getMonth() + 1, 0);

    return allTransactions.filter((transaction) => {
      const transactionDate = new Date(transaction.date);
      return transactionDate >= monthStart && transactionDate <= monthEnd;
    });
  } catch (error) {
    console.error("Error getting transactions for month:", error);
    throw error;
  }
};

export const updateTransaction = async (
  transaction: Transaction
): Promise<void> => {
  try {
    // Use the encrypted updateTransaction function from userData.ts
    const { updateTransaction: updateTransactionEncrypted } = await import(
      "./userData"
    );
    await updateTransactionEncrypted(transaction);
  } catch (error) {
    console.error("Error updating transaction:", error);
    throw error;
  }
};

export const deleteTransaction = async (
  userId: string,
  transactionId: string
): Promise<void> => {
  try {
    // First, find which month the transaction is in
    const transactionsRef = ref(db, `users/${userId}/transactions`);
    const snapshot = await get(transactionsRef);

    if (!snapshot.exists()) {
      throw new Error("Transaction not found");
    }

    let monthPath: string | null = null;
    let transactionFound = false;

    snapshot.forEach((monthSnapshot) => {
      if (monthSnapshot.key && monthSnapshot.hasChild(transactionId)) {
        monthPath = `users/${userId}/transactions/${monthSnapshot.key}/${transactionId}`;
        transactionFound = true;
      }
    });

    if (!transactionFound || !monthPath) {
      throw new Error("Transaction not found");
    }

    const transactionRef = ref(db, monthPath);
    await remove(transactionRef);
  } catch (error) {
    console.error("Error deleting transaction:", error);
    throw error;
  }
};

// ===== DYNAMIC TRANSACTION FILTERING UTILITIES =====

/**
 * Get transactions from the last N days (rolling window)
 * @param transactions - Array of transactions
 * @param days - Number of days to look back (default: 30)
 * @returns Filtered transactions from last N days
 */
export const getTransactionsFromLastDays = (
  transactions: Transaction[],
  days: number = 30
): Transaction[] => {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - days);

  return transactions.filter((t) => {
    const transactionDate = new Date(t.date);
    return transactionDate >= cutoffDate;
  });
};

/**
 * Get transactions from current month and previous month
 * @param transactions - Array of transactions
 * @returns Object with current and previous month transactions
 */
export const getCurrentAndPreviousMonthTransactions = (
  transactions: Transaction[]
): { current: Transaction[]; previous: Transaction[] } => {
  const now = new Date();
  const currentMonth = now.getMonth();
  const currentYear = now.getFullYear();
  const previousMonth = currentMonth === 0 ? 11 : currentMonth - 1;
  const previousYear = currentMonth === 0 ? currentYear - 1 : currentYear;

  const current = transactions.filter((t) => {
    const date = new Date(t.date);
    return (
      date.getMonth() === currentMonth && date.getFullYear() === currentYear
    );
  });

  const previous = transactions.filter((t) => {
    const date = new Date(t.date);
    return (
      date.getMonth() === previousMonth && date.getFullYear() === previousYear
    );
  });

  return { current, previous };
};

/**
 * Get transactions from a specific month (dynamic year)
 * @param transactions - Array of transactions
 * @param month - Month number (0-11, where 0 is January)
 * @param yearOffset - Years from current year (0 = current, -1 = last year, etc.)
 * @returns Filtered transactions for the specified month
 */
export const getTransactionsForMonthOffset = (
  transactions: Transaction[],
  month: number,
  yearOffset: number = 0
): Transaction[] => {
  const now = new Date();
  const targetYear = now.getFullYear() + yearOffset;

  return transactions.filter((t) => {
    const date = new Date(t.date);
    return date.getMonth() === month && date.getFullYear() === targetYear;
  });
};

/**
 * Get most recent transactions (last N transactions)
 * @param transactions - Array of transactions
 * @param count - Number of most recent transactions to return (default: 20)
 * @returns Most recent N transactions
 */
export const getMostRecentTransactions = (
  transactions: Transaction[],
  count: number = 20
): Transaction[] => {
  // Sort by date (newest first) and take first N
  return transactions
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
    .slice(0, count);
};

// ===== RECURRING TRANSACTIONS CRUD =====

export const createRecurringTransaction = async (
  recurringTransaction: Omit<RecurringTransaction, "id">,
  targetMonth?: Date
): Promise<string> => {
  try {
    // Use the encrypted saveRecurringTransaction function from userData.ts
    const { saveRecurringTransaction } = await import("./userData");

    // Calculate next due date and set initial values
    const recurringTransactionWithId = {
      ...recurringTransaction,
      id: "", // Will be generated by saveRecurringTransaction
      lastGeneratedDate: Date.now(),
      nextDueDate: calculateNextDueDate(recurringTransaction, new Date()),
      totalOccurrences: 0,
    };

    const transactionId = await saveRecurringTransaction(
      recurringTransactionWithId
    );

    // Optionally create the first actual transaction if user wants it
    if (targetMonth) {
      const shouldCreateFirstTransaction = checkIfTransactionShouldOccur(
        recurringTransactionWithId,
        new Date(targetMonth.getFullYear(), targetMonth.getMonth(), 1),
        new Date(targetMonth.getFullYear(), targetMonth.getMonth() + 1, 0)
      );

      if (shouldCreateFirstTransaction) {
        const firstTransaction: Transaction = {
          description: recurringTransaction.name,
          amount: recurringTransaction.amount,
          type: recurringTransaction.type,
          category: recurringTransaction.category,
          date: new Date(recurringTransaction.startDate).getTime(),
          userId: recurringTransaction.userId,
          recurringTransactionId: transactionId,
          isProjected: false,
          isManual: true, // Mark as manual transaction for matching
          // Preserve bank transaction metadata if this recurring transaction was created from a bank transaction (only if defined)
          ...(recurringTransaction.bankTransactionId && {
            bankTransactionId: recurringTransaction.bankTransactionId,
          }),
          ...(recurringTransaction.sourceAccountId && {
            sourceAccountId: recurringTransaction.sourceAccountId,
          }),
          ...(recurringTransaction.sourceInstitution && {
            sourceInstitution: recurringTransaction.sourceInstitution,
          }),
          ...(recurringTransaction.sourceItemId && {
            sourceItemId: recurringTransaction.sourceItemId,
          }),
          ...(recurringTransaction.isAutoImported !== undefined && {
            isAutoImported: recurringTransaction.isAutoImported,
          }),
        };

        await createTransaction(firstTransaction);

        // Update the recurring transaction with generation info
        await updateRecurringTransactionAfterGeneration(
          transactionId,
          recurringTransaction.userId
        );
      }
    }

    return transactionId;
  } catch (error) {
    console.error("Error creating recurring transaction:", error);
    throw error;
  }
};

export const getRecurringTransactions = async (
  userId: string
): Promise<RecurringTransaction[]> => {
  try {
    // Use the decrypted getUserRecurringTransactions function from userData.ts
    const { getUserRecurringTransactions } = await import("./userData");
    return await getUserRecurringTransactions(userId);
  } catch (error) {
    console.error("Error getting recurring transactions:", error);
    throw error;
  }
};

export const updateRecurringTransaction = async (
  recurringTransaction: RecurringTransaction
): Promise<void> => {
  try {
    // Use the encrypted updateRecurringTransaction function from userData.ts
    const { updateRecurringTransaction: updateRecurringTransactionEncrypted } =
      await import("./userData");
    await updateRecurringTransactionEncrypted(recurringTransaction);

    // CRITICAL: DO NOT update linked actual transactions
    // Historical actual transactions should NEVER be modified when recurring transactions change
    // This preserves data integrity and prevents historical data from disappearing
  } catch (error) {
    console.error("Error updating recurring transaction:", error);
    throw error;
  }
};

export const deleteRecurringTransaction = async (
  recurringTransactionId: string,
  userId: string
): Promise<void> => {
  try {
    console.log(
      `Attempting to delete recurring transaction: ${recurringTransactionId} for user: ${userId}`
    );

    // Delete the recurring transaction from the user's collection
    const recurringTransactionRef = ref(
      db,
      `users/${userId}/recurringTransactions/${recurringTransactionId}`
    );

    // First check if it exists
    const snapshot = await get(recurringTransactionRef);
    if (!snapshot.exists()) {
      console.log(
        `Recurring transaction ${recurringTransactionId} not found in database`
      );
      throw new Error("Recurring transaction not found");
    }

    console.log(
      `Found recurring transaction ${recurringTransactionId}, proceeding with deletion`
    );

    // Delete the recurring transaction
    await remove(recurringTransactionRef);
    console.log(
      "Recurring transaction deleted successfully from user collection"
    );

    // Optionally clean up any actual transactions that reference this recurring transaction
    // This is optional - you might want to keep historical data
    try {
      const transactionsRef = ref(db, `users/${userId}/transactions`);
      const transactionsSnapshot = await get(transactionsRef);

      if (transactionsSnapshot.exists()) {
        const transactionIdsToUpdate: string[] = [];

        // Search through all months to find transactions that reference this recurring transaction
        transactionsSnapshot.forEach((monthSnapshot) => {
          if (monthSnapshot.key && monthSnapshot.val()) {
            const monthTransactions = monthSnapshot.val();
            Object.keys(monthTransactions).forEach((transactionId) => {
              const transaction = monthTransactions[transactionId];
              if (
                transaction.recurringTransactionId === recurringTransactionId
              ) {
                transactionIdsToUpdate.push(
                  `${monthSnapshot.key}/${transactionId}`
                );
              }
            });
          }
        });

        // Remove the recurring transaction reference (but keep the actual transaction)
        for (const transactionPath of transactionIdsToUpdate) {
          const transactionRef = ref(
            db,
            `users/${userId}/transactions/${transactionPath}`
          );
          await update(transactionRef, {
            recurringTransactionId: null,
          });
        }

        if (transactionIdsToUpdate.length > 0) {
          console.log(
            `Updated ${transactionIdsToUpdate.length} transactions to remove recurring reference`
          );
        }
      }
    } catch (cleanupError) {
      console.warn(
        "Warning: Could not clean up transaction references:",
        cleanupError
      );
      // Don't fail the main deletion if cleanup fails
    }
  } catch (error) {
    console.error("Error deleting recurring transaction:", error);
    throw new Error("Failed to delete recurring transaction");
  }
};

// ===== MONTH OVERRIDE MANAGEMENT =====

// Delete a specific month override
export const deleteMonthOverride = async (
  userId: string,
  recurringTransactionId: string,
  monthKey: string
): Promise<void> => {
  try {
    const { getUserRecurringTransactions, updateRecurringTransaction } =
      await import("./userData");

    const recurringTransactions = await getUserRecurringTransactions(userId);
    const recurringTransaction = recurringTransactions.find(
      (rt: RecurringTransaction) => rt.id === recurringTransactionId
    );

    if (!recurringTransaction) {
      throw new Error("Recurring transaction not found");
    }

    // Remove the specific month override
    const monthOverrides = { ...(recurringTransaction.monthOverrides ?? {}) };
    delete monthOverrides[monthKey];

    // Update the recurring transaction
    const updatedRecurringTransaction = {
      ...recurringTransaction,
      monthOverrides,
      updatedAt: Date.now(),
    };

    await updateRecurringTransaction(updatedRecurringTransaction);
    console.log(`Deleted month override for ${monthKey}`);
  } catch (error) {
    console.error("Error deleting month override:", error);
    throw error;
  }
};

// Update a specific month override
export const updateMonthOverride = async (
  userId: string,
  recurringTransactionId: string,
  monthKey: string,
  override: { amount: number; category?: string; name?: string }
): Promise<void> => {
  try {
    const { getUserRecurringTransactions, updateRecurringTransaction } =
      await import("./userData");

    const recurringTransactions = await getUserRecurringTransactions(userId);
    const recurringTransaction = recurringTransactions.find(
      (rt: RecurringTransaction) => rt.id === recurringTransactionId
    );

    if (!recurringTransaction) {
      throw new Error("Recurring transaction not found");
    }

    // Update the specific month override
    const monthOverrides = { ...(recurringTransaction.monthOverrides ?? {}) };
    monthOverrides[monthKey] = {
      ...monthOverrides[monthKey],
      ...override,
    };

    // Update the recurring transaction
    const updatedRecurringTransaction = {
      ...recurringTransaction,
      monthOverrides,
      updatedAt: Date.now(),
    };

    await updateRecurringTransaction(updatedRecurringTransaction);
    console.log(`Updated month override for ${monthKey}:`, override);
  } catch (error) {
    console.error("Error updating month override:", error);
    throw error;
  }
};

// Get month override for a specific month
export const getMonthOverride = async (
  userId: string,
  recurringTransactionId: string,
  monthKey: string
): Promise<{ amount: number; category?: string; name?: string } | null> => {
  try {
    const { getUserRecurringTransactions } = await import("./userData");

    const recurringTransactions = await getUserRecurringTransactions(userId);
    const recurringTransaction = recurringTransactions.find(
      (rt: RecurringTransaction) => rt.id === recurringTransactionId
    );

    if (!recurringTransaction) {
      return null;
    }

    return recurringTransaction.monthOverrides?.[monthKey] || null;
  } catch (error) {
    console.error("Error getting month override:", error);
    throw error;
  }
};

// ===== SMART RECURRING TRANSACTION SYSTEM =====

// Get smart transactions for a month (actual + projected)
export const getSmartTransactionsForMonth = async (
  userId: string,
  targetMonth: Date
): Promise<Transaction[]> => {
  try {
    // Get actual transactions for the month
    const actualTransactions = await getTransactionsForMonth(
      userId,
      targetMonth
    );

    // Get projected transactions for the month
    const { projected } = await getProjectedTransactionsForMonth(
      userId,
      targetMonth
    );

    // Combine and sort by date
    const allTransactions = [...actualTransactions, ...projected].sort(
      (a, b) => a.date - b.date
    );

    return allTransactions;
  } catch (error) {
    console.error("Error getting smart transactions for month:", error);
    throw error;
  }
};

// ===== FUTURE MONTH PROJECTIONS =====

export const getProjectedTransactionsForMonth = async (
  userId: string,
  targetMonth: Date
): Promise<{ actual: Transaction[]; projected: Transaction[] }> => {
  try {
    // Get actual transactions for the month
    const actualTransactions = await getTransactionsForMonth(
      userId,
      targetMonth
    );

    // Get recurring transactions
    const recurringTransactions = await getRecurringTransactions(userId);

    const projectedTransactions: Transaction[] = [];
    const targetMonthStart = new Date(
      targetMonth.getFullYear(),
      targetMonth.getMonth(),
      1
    );
    const targetMonthEnd = new Date(
      targetMonth.getFullYear(),
      targetMonth.getMonth() + 1,
      0
    );

    // Use the helper function to determine month type
    const monthType = getMonthType(targetMonth);
    const { isPastMonth, isCurrentMonth, isFutureMonth } = monthType;

    for (const recurringTransaction of recurringTransactions) {
      if (!recurringTransaction.isActive) continue;

      // CRITICAL: Different handling based on month type
      if (isPastMonth) {
        // PAST MONTHS: Never create projected transactions
        // Historical data should be completely preserved
        continue;
      }

      // Check if this recurring transaction should occur in the target month
      const shouldOccur = checkIfTransactionShouldOccur(
        recurringTransaction,
        targetMonthStart,
        targetMonthEnd
      );

      if (shouldOccur) {
        // Check if an actual transaction already exists for this recurring transaction in this month
        const alreadyExists = actualTransactions.some(
          (transaction) =>
            transaction.recurringTransactionId === recurringTransaction.id
        );

        if (!alreadyExists) {
          // Create projected transaction for current/future months
          const transactionDate = getNextOccurrenceDate(
            recurringTransaction,
            targetMonthStart
          );

          // Check for month-specific override
          const monthKey = `${targetMonth.getFullYear()}-${String(
            targetMonth.getMonth() + 1
          ).padStart(2, "0")}`;
          const monthOverride = recurringTransaction.monthOverrides?.[monthKey];

          const projectedTransaction: Transaction = {
            id: `projected-${
              recurringTransaction.id
            }-${targetMonth.getTime()}-${Date.now()}-${Math.random()
              .toString(36)
              .substr(2, 9)}`,
            amount: monthOverride?.amount || recurringTransaction.amount,
            type: recurringTransaction.type,
            category: monthOverride?.category || recurringTransaction.category,
            description: monthOverride?.name || recurringTransaction.name,
            date: transactionDate.getTime(),
            userId: userId,
            recurringTransactionId: recurringTransaction.id,
            isProjected: true,
          };

          projectedTransactions.push(projectedTransaction);
        }
      }
    }

    return {
      actual: actualTransactions,
      projected: projectedTransactions,
    };
  } catch (error) {
    console.error("Error getting projected transactions:", error);
    throw error;
  }
};

// ===== UTILITY FUNCTIONS =====

// Skip a recurring transaction for a specific month
export const skipRecurringTransactionForMonth = async (
  userId: string,
  recurringTransactionId: string,
  monthKey: string
): Promise<void> => {
  try {
    const { skipRecurringTransactionForMonth: skipRecurringMonth } =
      await import("./userData");

    await skipRecurringMonth(recurringTransactionId, monthKey, userId);
  } catch (error) {
    console.error("Error skipping recurring transaction for month:", error);
    throw error;
  }
};

// Convert projected transaction to actual transaction
export const convertProjectedToActual = async (
  userId: string,
  recurringTransactionId: string,
  targetMonth: Date
): Promise<string> => {
  try {
    const { getUserRecurringTransactions } = await import("./userData");
    const recurringTransactions = await getUserRecurringTransactions(userId);
    const recurringTransaction = recurringTransactions.find(
      (rt: RecurringTransaction) => rt.id === recurringTransactionId
    );

    if (!recurringTransaction) {
      throw new Error("Recurring transaction not found");
    }

    // Create actual transaction
    const actualTransaction: Transaction = {
      description: recurringTransaction.name,
      amount: recurringTransaction.amount,
      type: recurringTransaction.type,
      category: recurringTransaction.category,
      date: getNextOccurrenceDate(recurringTransaction, targetMonth).getTime(),
      userId: userId,
      recurringTransactionId: recurringTransactionId,
      isProjected: false,
      isManual: true, // Mark as manual transaction for matching
      // Preserve bank transaction metadata if this recurring transaction was created from a bank transaction (only if defined)
      ...(recurringTransaction.bankTransactionId && {
        bankTransactionId: recurringTransaction.bankTransactionId,
      }),
      ...(recurringTransaction.sourceAccountId && {
        sourceAccountId: recurringTransaction.sourceAccountId,
      }),
      ...(recurringTransaction.sourceInstitution && {
        sourceInstitution: recurringTransaction.sourceInstitution,
      }),
      ...(recurringTransaction.sourceItemId && {
        sourceItemId: recurringTransaction.sourceItemId,
      }),
      ...(recurringTransaction.isAutoImported !== undefined && {
        isAutoImported: recurringTransaction.isAutoImported,
      }),
    };

    const transactionId = await createTransaction(actualTransaction);

    // Update recurring transaction tracking
    await updateRecurringTransactionAfterGeneration(
      recurringTransactionId,
      userId
    );

    return transactionId;
  } catch (error) {
    console.error("Error converting projected to actual transaction:", error);
    throw error;
  }
};

// Calculate next due date for recurring transactions
const calculateNextDueDate = (
  recurringTransaction: RecurringTransaction,
  fromDate: Date
): number => {
  const startDate = new Date(recurringTransaction.startDate);

  switch (recurringTransaction.frequency) {
    case "weekly":
      return new Date(fromDate.getTime() + 7 * 24 * 60 * 60 * 1000).getTime();
    case "biweekly":
      return new Date(fromDate.getTime() + 14 * 24 * 60 * 60 * 1000).getTime();
    case "monthly":
      const nextMonth = new Date(fromDate);
      nextMonth.setMonth(nextMonth.getMonth() + 1);
      return nextMonth.getTime();
    case "quarterly":
      const nextQuarter = new Date(fromDate);
      nextQuarter.setMonth(nextQuarter.getMonth() + 3);
      return nextQuarter.getTime();
    case "yearly":
      const nextYear = new Date(fromDate);
      nextYear.setFullYear(nextYear.getFullYear() + 1);
      return nextYear.getTime();
    default:
      return fromDate.getTime();
  }
};

// Update recurring transaction after generating an actual transaction
const updateRecurringTransactionAfterGeneration = async (
  recurringTransactionId: string,
  userId: string
): Promise<void> => {
  try {
    const { updateRecurringTransaction } = await import("./userData");
    const { getUserRecurringTransactions } = await import("./userData");

    const recurringTransactions = await getUserRecurringTransactions(userId);
    const recurringTransaction = recurringTransactions.find(
      (rt: RecurringTransaction) => rt.id === recurringTransactionId
    );

    if (recurringTransaction) {
      await updateRecurringTransaction({
        ...recurringTransaction,
        lastGeneratedDate: Date.now(),
        nextDueDate: calculateNextDueDate(recurringTransaction, new Date()),
        totalOccurrences: (recurringTransaction.totalOccurrences || 0) + 1,
      });
    }
  } catch (error) {
    console.error(
      "Error updating recurring transaction after generation:",
      error
    );
  }
};

export const generateTransactionsForMonth = async (
  userId: string,
  targetMonth: Date
): Promise<void> => {
  try {
    const recurringTransactions = await getRecurringTransactions(userId);
    const targetMonthStart = new Date(
      targetMonth.getFullYear(),
      targetMonth.getMonth(),
      1
    );
    const targetMonthEnd = new Date(
      targetMonth.getFullYear(),
      targetMonth.getMonth() + 1,
      0
    );

    for (const recurringTransaction of recurringTransactions) {
      if (!recurringTransaction.isActive) continue;

      // Check if transaction should occur in target month
      const shouldGenerate = checkIfTransactionShouldOccur(
        recurringTransaction,
        targetMonthStart,
        targetMonthEnd
      );

      if (shouldGenerate) {
        // Check if transaction already exists for this month
        const existingTransactions = await getTransactionsForMonth(
          userId,
          targetMonth
        );

        const transactionExists = existingTransactions.some(
          (transaction) =>
            transaction.description === recurringTransaction.name &&
            transaction.amount === recurringTransaction.amount &&
            transaction.type === recurringTransaction.type
        );

        if (!transactionExists) {
          // Generate the transaction
          const transactionDate = getNextOccurrenceDate(
            recurringTransaction,
            targetMonthStart
          );

          const newTransaction: Transaction = {
            description: recurringTransaction.name,
            amount: recurringTransaction.amount,
            type: recurringTransaction.type,
            category: recurringTransaction.category,
            date: transactionDate.getTime(),
            userId: userId,
            recurringTransactionId: recurringTransaction.id, // Reference to the recurring transaction
            isManual: true, // Mark as manual transaction for matching
          };

          await createTransaction(newTransaction);
        }
      }
    }
  } catch (error) {
    console.error("Error generating transactions for month:", error);
    throw error;
  }
};

// ===== HELPER FUNCTIONS =====

/**
 * Determines the type of month for proper transaction handling
 * @param targetMonth - The month to analyze
 * @returns Object with month classification
 */
const getMonthType = (targetMonth: Date) => {
  const currentDate = new Date();
  const currentMonthStart = new Date(
    currentDate.getFullYear(),
    currentDate.getMonth(),
    1
  );

  const targetMonthStart = new Date(
    targetMonth.getFullYear(),
    targetMonth.getMonth(),
    1
  );

  const isPastMonth = targetMonthStart < currentMonthStart;
  const isCurrentMonth =
    targetMonthStart.getTime() === currentMonthStart.getTime();
  const isFutureMonth = targetMonthStart > currentMonthStart;

  return {
    isPastMonth,
    isCurrentMonth,
    isFutureMonth,
    targetMonthStart,
    currentMonthStart,
  };
};

const checkIfTransactionShouldOccur = (
  recurringTransaction: RecurringTransaction,
  monthStart: Date,
  monthEnd: Date
): boolean => {
  const startDate = new Date(recurringTransaction.startDate);

  if (startDate > monthEnd) return false;

  if (
    recurringTransaction.endDate &&
    new Date(recurringTransaction.endDate) < monthStart
  ) {
    return false;
  }

  // Check if this month is in the skipped months list
  const monthKey = `${monthStart.getFullYear()}-${String(
    monthStart.getMonth() + 1
  ).padStart(2, "0")}`;
  if (
    recurringTransaction.skippedMonths &&
    recurringTransaction.skippedMonths.includes(monthKey)
  ) {
    return false;
  }

  switch (recurringTransaction.frequency) {
    case "weekly":
      return monthStart >= startDate;
    case "biweekly":
      const weeksSinceStart = Math.floor(
        (monthStart.getTime() - startDate.getTime()) / (7 * 24 * 60 * 60 * 1000)
      );
      return weeksSinceStart >= 0 && weeksSinceStart % 2 === 0;
    case "monthly":
      const monthsSinceStart =
        (monthStart.getFullYear() - startDate.getFullYear()) * 12 +
        (monthStart.getMonth() - startDate.getMonth());
      return monthsSinceStart >= 0;
    case "quarterly":
      const quarterlyMonthsSinceStart =
        (monthStart.getFullYear() - startDate.getFullYear()) * 12 +
        (monthStart.getMonth() - startDate.getMonth());
      return (
        quarterlyMonthsSinceStart >= 0 && quarterlyMonthsSinceStart % 3 === 0
      );
    case "yearly":
      const yearsSinceStart =
        monthStart.getFullYear() - startDate.getFullYear();
      return yearsSinceStart >= 0;
    default:
      return false;
  }
};

const getNextOccurrenceDate = (
  recurringTransaction: RecurringTransaction,
  monthStart: Date
): Date => {
  const startDate = new Date(recurringTransaction.startDate);

  switch (recurringTransaction.frequency) {
    case "weekly":
      return new Date(monthStart.getTime() + 7 * 24 * 60 * 60 * 1000);
    case "biweekly":
      return new Date(monthStart.getTime() + 14 * 24 * 60 * 60 * 1000);
    case "monthly":
      const dayOfMonth = startDate.getDate();
      const lastDayOfMonth = new Date(
        monthStart.getFullYear(),
        monthStart.getMonth() + 1,
        0
      ).getDate();
      const actualDay = Math.min(dayOfMonth, lastDayOfMonth);
      return new Date(
        monthStart.getFullYear(),
        monthStart.getMonth(),
        actualDay
      );
    case "quarterly":
      const quarterDayOfMonth = startDate.getDate();
      const quarterLastDayOfMonth = new Date(
        monthStart.getFullYear(),
        monthStart.getMonth() + 1,
        0
      ).getDate();
      const quarterActualDay = Math.min(
        quarterDayOfMonth,
        quarterLastDayOfMonth
      );
      return new Date(
        monthStart.getFullYear(),
        monthStart.getMonth(),
        quarterActualDay
      );
    case "yearly":
      const yearlyDayOfMonth = startDate.getDate();
      const yearlyLastDayOfMonth = new Date(
        monthStart.getFullYear(),
        startDate.getMonth() + 1,
        0
      ).getDate();
      const yearlyActualDay = Math.min(yearlyDayOfMonth, yearlyLastDayOfMonth);
      return new Date(
        monthStart.getFullYear(),
        startDate.getMonth(),
        yearlyActualDay
      );
    default:
      return monthStart;
  }
};

// Update end date for recurring transaction
export const updateRecurringTransactionEndDate = async (
  userId: string,
  recurringTransactionId: string,
  endDate: number | undefined
): Promise<void> => {
  try {
    const { getUserRecurringTransactions, updateRecurringTransaction } =
      await import("./userData");

    const recurringTransactions = await getUserRecurringTransactions(userId);
    const recurringTransaction = recurringTransactions.find(
      (rt: RecurringTransaction) => rt.id === recurringTransactionId
    );

    if (!recurringTransaction) {
      throw new Error("Recurring transaction not found");
    }

    // Update the recurring transaction with the new end date
    const updatedRecurringTransaction = {
      ...recurringTransaction,
      endDate,
      updatedAt: Date.now(),
    };

    await updateRecurringTransaction(updatedRecurringTransaction);

    if (endDate) {
      console.log(
        `Updated end date for recurring transaction: ${new Date(
          endDate
        ).toLocaleDateString()}`
      );
    } else {
      console.log("Removed end date from recurring transaction");
    }
  } catch (error) {
    console.error("Error updating recurring transaction end date:", error);
    throw error;
  }
};
